#!/usr/bin/env python
# encoding: utf-8
# 作者：Ksar4
# 日期：2021/1/27 11:44
# 工具：PyCharm
# Python版本：3.7.0
""""""

"""
一. 两者区别
进程是分配资源的基本单位；线程是系统调度和分派的基本单位。
属于同一进程的线程，堆是共享的，栈是私有的。
属于同一进程的所有线程都具有相同的地址空间。

多进程的优点：
①编程相对容易；通常不需要考虑锁和同步资源的问题。
②更强的容错性：比起多线程的一个好处是一个进程崩溃了不会影响其他进程。
③有内核保证的隔离：数据和错误隔离。 对于使用如C/C++这些语言编写的本地代码，错误隔离是非常有用的：采用多进程架构的程序一般可以做到一定程度的自恢复；（master守护进程监控所有worker进程，发现进程挂掉后将其重启）。
多线程的优点：
①创建速度快，方便高效的数据共享
共享数据：多线程间可以共享同一虚拟地址空间；多进程间的数据共享就需要用到共享内存、信号量等IPC技术。
②较轻的上下文切换开销 - 不用切换地址空间，不用更改寄存器，不用刷新TLB。
③提供非均质的服务。如果全都是计算任务，但每个任务的耗时不都为1s，而是1ms-1s之间波动；这样，多线程相比多进程的优势就体现出来，它能有效降低“简单任务被复杂任务压住”的概率。


多线程与多进程 与 计算密集型任务 和 IO密集型任务 关系?
多线程适合IO密集型任务。
多进程适合计算密集型任务

"""











"""
线程池的应用场景
1、newSingleThreadExecutor：一个单线程的线程池，可以用于需要保证顺序执行的场景，并且只有一个线程在执行。
2、newFixedThreadPool：一个固定大小的线程池，可以用于已知并发压力的情况下，对线程数做限制。
3、newCachedThreadPool：一个可以无限扩大的线程池，比较适合处理执行时间比较小的任务。
4、newScheduledThreadPool：可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。
5、newWorkStealingPool：一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用cpu数量的线程来并行执行。

线程池的运行过程

　　(1) 刚开始运行时，线程池是空的

　　(2) 一个任务进来，检查池中的线程数量，是否达到corePoolSize，如果没有达到，则创建线程，执行任务

　　(3) 任务执行完成之后，线程不会销毁，而是阻塞的等待下一个任务

　　(4) 又进来一个任务，不是直接使用阻塞的线程，而是检查线程池中的线程数大小，是否达到corePoolSize，如果没有达到，则继续创建新的线程，来执行新的任务，如此往复，
       直到线程池中的线程数达到corePoolSize，此时停止创建新的线程

　　(5) 此时，又来新的任务，会选择线程池中阻塞等待的线程来执行任务，有一个任务进来，唤醒一个线程来执行这个任务，处理完之后，再次阻塞，
       尝试在workQueue上获取下一个任务，如果线程池中没有可唤醒的线程，则任务进入workQueue，排队等待

　　(6) 如果队列是无界队列，比如LinkedBlockingQueue，默认最大容量为Integer.MAX，接近于无界，可用无限制的接收任务，如果队列是有界队列，
       比如ArrayBlockingQueue，可限定队列大小，当线程池中的线程来不及处理，然后，所有的任务都进入队列，队列的任务数也达到限定大小，此时，
       再来新的任务，就会入队失败，然后，就会再次尝试在线程池里创建线程，直到线程数达到maximumPoolSize，停止创建线程

　　(7)此时，队列满了，新的任务无法入队，创建的线程数也达到了maximumPoolSize，无法再创建新的线程，
      此时，就会reject掉，使用拒绝策略RejectedExecutionHandler，不让继续提交任务，默认的是AbortPolicy策略，拒绝，并抛出异常

　　(8) 超出corePoolSize数创建的那部分线程，是跟空闲时间keepAliveTime相关的，如果超过keepAliveTime时间还获取不到任务，线程会被销毁，自动释放掉
"""



